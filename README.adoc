= Pitest - demo
:toc:
:toc-placement:

== Introduction

Pitest is a library that helps us do mutation testing, and thus helps us get a measure of the quality of our tests.
It works by randomly seeding variations (aka mutants) in the code that's being tested.
Hence, our tests will run against variants of the code we're intending to test.
If the test fails, the mutation is killed, if it still passes it lives.

Surviving mutations may indicate issues with our test set, since application code changes should lead to different end results and thus to failing tests.

Mutations can take a lot of forms, relational operators being switched around, increments becoming decrements, calls to void methods being removed, ...
A full list be be found on the https://pitest.org/quickstart/mutators/[Pitest Mutator Overview Page]

== Ok, but why?

By default, coverage reports give us information on what code is (not) tested, but no indication on whether our tests are actually able to detect issues properly.
After all, who here hasn't seen a codebase where the tests contain no asserts, yet all branches are executed?

== A short demo

Let's run `mvn test` on this project, and we'll get this magnificent jacoco project:

image::raw/jacoco.png[]

A line & branch coverage of 100% magnificent isn't it?
Of course if we then take a look at our link:src/test/java/dev/simonverhoeven/pitestdemo/MainTest.java[tests] the keen eyed will spot the lack of assertions.



== Notes

* PIT can take a while to run
* Pitest is deterministic, not random

== References

* https://pitest.org/[Official website]
* https://www.arcmutate.com/[Arcmutate] - from the team behind Pitest, offers extra operators
* https://github.com/STAMP-project/pitest-descartes[Descartes] - a mutation plugin engine for PIT implementing extreme mutation operators